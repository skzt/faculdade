import os
from random import shuffle, randint
from time import strftime

import cv2
import numpy as np
from keras.callbacks import TensorBoard
from keras.layers import Activation
from keras.layers import Conv2D
from keras.layers import Dense
from keras.layers import Flatten
from keras.layers import MaxPooling2D
from keras.layers import Dropout
from keras.models import Sequential
from keras.optimizers import Adam
from keras.utils import to_categorical
from tqdm.auto import tqdm
from keras_tqdm import TQDMNotebookCallback

DIR_TREINO = "../Datasets/alexandre/train"
MODEL_NAME = "alexandre01"
LR = 0.001
ROW_SIZE = 8
COL_SIZE = 5
EPOCHS = 10
CLASSES = 10


def lprNet():
    new_model = Sequential()

    new_model.add(Conv2D(32, kernel_size=(2, 2), input_shape=(ROW_SIZE, COL_SIZE, 1)))
    new_model.add(Activation('relu'))
    # new_model.add(MaxPooling2D(5))

    new_model.add(Conv2D(64, kernel_size=(2, 2)))
    new_model.add(Activation('relu'))
    new_model.add(MaxPooling2D())

    # new_model.add(Conv2D(128, kernel_size=(1, 1)))
    # new_model.add(Activation('relu'))
    # new_model.add(MaxPooling2D(1))
    #
    # new_model.add(Conv2D(64, kernel_size=(1, 1)))
    # new_model.add(Activation('relu'))
    # new_model.add(MaxPooling2D(1))
    #
    # new_model.add(Conv2D(32, kernel_size=(1, 1)))
    # new_model.add(Activation('relu'))
    # new_model.add(MaxPooling2D(1))

    new_model.add(Flatten())
    new_model.add(Dense(64))
    new_model.add(Activation('relu'))
    # new_model.add(Dropout(0.2))

    new_model.add(Dense(CLASSES, activation="softmax"))

    return new_model


def generateData():
    training_data = []
    testing_data = []

    # Algoritimo para Dataset Alexandre
    for num_folder in range(10):
        test_labels = os.listdir(os.path.join(DIR_TREINO, str(num_folder)))
        train_labels = []
        # Loop responsavel por separar as labels de treino e test
        for i in range(15):
            index = randint(0, 17 - i)
            train_labels.append(test_labels[index])
            test_labels = test_labels[:index] + test_labels[index + 1:]

        for img_name in train_labels:
                img = cv2.imread(os.path.join(DIR_TREINO, str(num_folder), img_name),
                                 cv2.IMREAD_GRAYSCALE)
                img = cv2.resize(img, (ROW_SIZE, COL_SIZE))
                training_data.append([img, to_categorical(str(num_folder), CLASSES, dtype='uint8')])

        for img_name in test_labels:
                img = cv2.imread(os.path.join(DIR_TREINO, str(num_folder), img_name),
                                 cv2.IMREAD_GRAYSCALE)
                img = cv2.resize(img, (ROW_SIZE, COL_SIZE))
                testing_data.append([img, to_categorical(str(num_folder), CLASSES, dtype='uint8')])

    shuffle(training_data)
    shuffle(testing_data)

    trainX = np.array([img[0] for img in training_data])
    trainX = trainX.reshape(-1, ROW_SIZE, COL_SIZE, 1)
    trainX = trainX / 255.0

    trainY = np.array([img[1] for img in training_data])
    print("Treino")
    print(trainY[:12])
    print(trainY[0].shape)

    testX = np.array([img[0] for img in testing_data])
    testX = testX.reshape(-1, ROW_SIZE, COL_SIZE, 1)
    testX = testX / 255.0

    testY = np.array([img[1] for img in testing_data])
    print("Validação")
    print(testY[:12])
    print(testY[0].shape)
    return trainX, trainY, testX, testY


def treinar(tensorboard):
    for _ in range(int(EPOCHS/10)):
        X, Y, test_x, test_y = generateData()
        model.fit(X,
                  Y,
                  batch_size=32,
                  epochs=10,
                  validation_data=(test_x, test_y),
                  callbacks=[TQDMNotebookCallback(leave_inner=True, leave_outer=True),
                             tensorboard],
                  verbose=0
                  )
        # TODO: testar com os test_x antes do proximo fit
    model.save(f"{MODEL_NAME}.h5")


model = lprNet()

optimizer = Adam(lr=LR)

tensorBoard = TensorBoard(log_dir=f"../logs/alexandre/{MODEL_NAME}-{strftime('%d-%m-%Y')}-{strftime('%H-%M-%S')}")

model.compile(optimizer=optimizer, loss='categorical_crossentropy', metrics=['accuracy'])

treinar(tensorBoard)

